use crate::sphincs_plus::SphincsContext;
use crate::wots_plus::adrs::Adrs;

#[cfg(feature = "sphincs_sha2_128f")]
use crate::sphincs_plus::params_sphincs_sha2_128f::*;
#[cfg(feature = "sphincs_sha2_128s")]
use crate::sphincs_plus::params_sphincs_sha2_128s::*;
#[cfg(feature = "sphincs_sha2_192f")]
use crate::sphincs_plus::params_sphincs_sha2_192f::*;
#[cfg(feature = "sphincs_sha2_192s")]
use crate::sphincs_plus::params_sphincs_sha2_192s::*;
#[cfg(feature = "sphincs_sha2_256f")]
use crate::sphincs_plus::params_sphincs_sha2_256f::*;
#[cfg(feature = "sphincs_sha2_256s")]
use crate::sphincs_plus::params_sphincs_sha2_256s::*;
#[cfg(feature = "sphincs_shake_128f")]
use crate::sphincs_plus::params_sphincs_shake_128f::*;
#[cfg(feature = "sphincs_shake_128s")]
use crate::sphincs_plus::params_sphincs_shake_128s::*;
#[cfg(feature = "sphincs_shake_192f")]
use crate::sphincs_plus::params_sphincs_shake_192f::*;
#[cfg(feature = "sphincs_shake_192s")]
use crate::sphincs_plus::params_sphincs_shake_192s::*;
#[cfg(feature = "sphincs_shake_256f")]
use crate::sphincs_plus::params_sphincs_shake_256f::*;
#[cfg(feature = "sphincs_shake_256s")]
use crate::sphincs_plus::params_sphincs_shake_256s::*;

use crate::utils::{bytes_to_u32, bytes_to_u64};
#[cfg(any(
    feature = "sphincs_shake_128f",
    feature = "sphincs_shake_128s",
    feature = "sphincs_shake_192f",
    feature = "sphincs_shake_192s",
    feature = "sphincs_shake_256f",
    feature = "sphincs_shake_256s",
))]
use sha3::{
    digest::{ExtendableOutput, Update, XofReader},
    Shake256,
};

fn shake256(output: &mut [u8], input: &[u8]) {
    let mut hasher = Shake256::default();
    hasher.update(input);
    let mut reader = hasher.finalize_xof();
    reader.read(output);
}

/// Computes the message hash using R, the public key, and the message.
/// Outputs the message digest and the index of the leaf. The index is split in
/// the tree index and the leaf index, for convenient copying to an address.
///
/// H_msg(R, PK.seed, PK.root, M ) = SHAKE256(R||PK.seed||PK.root||M, 8m),
pub fn h_msg(
    digest: &mut [u8],
    tree: &mut [u64],
    leaf_idx: &mut [u32],
    r: &[u8],
    pk: &[u8],
    m: &[u8],
) {
    const SPX_TREE_BITS: usize = SPX_TREE_HEIGHT * (SPX_D - 1);
    const SPX_TREE_BYTES: usize = (SPX_TREE_BITS + 7) / 8;
    const SPX_LEAF_BITS: usize = SPX_TREE_HEIGHT;
    const SPX_LEAF_BYTES: usize = (SPX_LEAF_BITS + 7) / 8;
    const SPX_DGST_BYTES: usize = SPX_FORS_MSG_BYTES + SPX_TREE_BYTES + SPX_LEAF_BYTES;

    let mut hasher = Shake256::default();
    hasher.update(r);
    hasher.update(pk);
    hasher.update(m);
    let mut reader = hasher.finalize_xof();

    let mut buf_digest = [0_u8; SPX_FORS_MSG_BYTES];
    reader.read(buf_digest.as_mut());
    digest[..SPX_FORS_MSG_BYTES].copy_from_slice(buf_digest.as_slice());

    let mut buf_tree = [0_u8; SPX_TREE_BYTES];
    reader.read(buf_tree.as_mut());
    let mut t = bytes_to_u64(&buf_tree);
    t &= (!0_u64) >> (64 - SPX_TREE_BITS);
    tree[0] = t;

    let mut buf_lead_idx = [0_u8; SPX_LEAF_BYTES];
    reader.read(buf_lead_idx.as_mut());
    let mut l = bytes_to_u32(&buf_lead_idx);
    l &= (!0_u32) >> (32 - SPX_LEAF_BITS);
    leaf_idx[0] = l;
}

/// Takes an array of inblocks concatenated arrays of SPX_N bytes. outlen=SP_X
/// (thash)
///
/// F(PK.seed, ADRS, M1 ) = SHAKE256(PK.seed||ADRS||M1 , 8n)
pub fn spx_f(output: &mut [u8], input: &[u8], in_blocks: usize, ctx: &SphincsContext, adrs: &Adrs) {
    // assert_eq!(input.len(), in_blocks);
    let mut hasher = Shake256::default();
    hasher.update(&ctx.pub_seed);
    hasher.update(adrs.as_ref());
    hasher.update(input);
    let mut reader = hasher.finalize_xof();

    // output can be given directly to read() method, which is faster,
    // but this makes sure the returned output is of proper size.
    let mut buf = [0_u8; SPX_N];
    reader.read(buf.as_mut());
    output[..SPX_N].copy_from_slice(buf.as_slice());
}

/// Applies [`spx_f`] function, but modifies the given input in place.
pub fn spx_f_inplace(inout: &mut [u8], in_blocks: usize, ctx: &SphincsContext, adrs: &Adrs) {
    // assert_eq!(input.len(), in_blocks);
    let mut hasher = Shake256::default();
    hasher.update(&ctx.pub_seed);
    hasher.update(adrs.as_ref());
    hasher.update(inout);
    let mut reader = hasher.finalize_xof();

    // output can be given directly to read() method, which is faster,
    // but this makes sure the returned output is of proper size.
    let mut buf = [0_u8; SPX_N];
    reader.read(buf.as_mut());
    inout[..SPX_N].copy_from_slice(buf.as_slice());
}

/// H(PK.seed, ADRS, M1 ||M2 ) = SHAKE256(PK.seed||ADRS||M1 ||M2 , 8n),
pub fn spx_h(
    output: &mut [u8],
    input1: &[u8],
    in_blocks1: usize,
    input2: &[u8],
    in_blocks2: usize,
    ctx: &SphincsContext,
    adrs: &Adrs,
) {
    assert_eq!(input1.len(), in_blocks1);
    assert_eq!(input2.len(), in_blocks2);
    let mut hasher = Shake256::default();
    hasher.update(&ctx.pub_seed);
    hasher.update(adrs.as_ref());
    hasher.update(input1);
    hasher.update(input2);
    let mut reader = hasher.finalize_xof();

    let mut buf = [0_u8; SPX_N];
    reader.read(buf.as_mut());
    output[..SPX_N].copy_from_slice(buf.as_slice());
}

/// T_l(PK.seed, ADRS, M ) = SHAKE256(PK.seed||ADRS||M, 8n),
pub fn spx_t_l(
    output: &mut [u8],
    input: &[u8],
    in_blocks: usize,
    ctx: &SphincsContext,
    adrs: &Adrs,
) {
    spx_f(output, input, in_blocks, ctx, adrs);
}

/// PRF(PK.seed, SK.seed, ADRS) = SHAKE256(PK.seed||ADRS||SK.seed, 8n),
///
/// (prf_addr)
pub fn spx_prf(output: &mut [u8], ctx: &SphincsContext, adrs: &Adrs) {
    spx_f(output, ctx.sk_seed.as_ref(), 1, ctx, adrs);
}

pub fn spx_prf_msg(
    output: &mut [u8],
    input: &[u8],
    in_blocks: usize,
    ctx: &SphincsContext,
    adrs: &Adrs,
) {
    assert_eq!(input.len(), in_blocks);
    let mut hasher = Shake256::default();
    hasher.update(&ctx.pub_seed);
    hasher.update(adrs.as_ref());
    hasher.update(input);
    let mut reader = hasher.finalize_xof();

    // output can be given directly to read() method, which is faster,
    // but this makes sure the returned output is of proper size.
    let mut buf = [0_u8; SPX_N];
    reader.read(buf.as_mut());
    output[..SPX_N].copy_from_slice(buf.as_slice());
}
